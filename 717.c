/**
一种思路是从头遍历，遇到1说明遇到了第二个字符，下标+2，遇到0说明遇到了第一个字符，下标+1，最后判断下标是不是正好能落到数组最后一位。
上述思路无论如何都要遍历一遍数组，实际上只需判断数组一部分后缀就能求解。
考虑如下几个后缀：
   00,Ture
  010,False
 0110,True
01110,False
直观判断可以发现，最后两个0之间1的个数是偶数时结果为True，否则为False。
实际上，因为数组是由0，10，11所组成的，所以数组中一旦出现01，就意味着出现了字符分界点，前一个字符要么是0，要么是10，后一个字符要么是10，要么是11。
因为数组一定是合法的，所以最后一个分界点之前的部分一定可以变成某种字符组合，可以不用管它，只看分界点之后的部分是什么字符组合。
这时问题转化成找到最后一个分界点，也就是找到倒数第二个0。最后两个0之间必然都是由1组成的，在去掉若干个11后，分界点之后的部分不是剩下0，就是剩下10。
**/

bool isOneBitCharacter(int* bits, int bitsSize) {
    int count_1 = 0;
    for(int i = bitsSize - 2; i >= 0; --i) {
        if(bits[i] == 0) {
            break;
        } else {
            count_1++;
        }
    }
    if(count_1 % 2 == 0) return true;
    return false;
}
